import {
  UNDEFINED,
  getTimestamp,
  mergeObjects,
  serialize,
  useIsomorphicLayoutEffect,
  useSWR,
  useSWRConfig,
  useStateWithDeps,
  withMiddleware
} from "./chunk-QKXPV5VX.js";
import "./chunk-DZNVQV5V.js";
import {
  require_react
} from "./chunk-ABDRZE5M.js";
import {
  __toESM
} from "./chunk-LFBQMW2U.js";

// node_modules/swr/mutation/dist/index.mjs
var import_react = __toESM(require_react(), 1);
var mutation = () => {
  return (key, fetcher, config = {}) => {
    const { mutate } = useSWRConfig();
    const keyRef = (0, import_react.useRef)(key);
    const fetcherRef = (0, import_react.useRef)(fetcher);
    const ditchMutationsUntilRef = (0, import_react.useRef)(0);
    const [stateRef, stateDependencies, setState] = useStateWithDeps({
      data: UNDEFINED,
      error: UNDEFINED,
      isMutating: false
    });
    const currentState = stateRef.current;
    const trigger = (0, import_react.useCallback)(
      async (arg, opts) => {
        const [serializedKey, resolvedKey] = serialize(keyRef.current);
        if (!fetcherRef.current) {
          throw new Error("Can’t trigger the mutation: missing fetcher.");
        }
        if (!serializedKey) {
          throw new Error("Can’t trigger the mutation: missing key.");
        }
        const options = mergeObjects(mergeObjects({
          populateCache: false,
          throwOnError: true
        }, config), opts);
        const mutationStartedAt = getTimestamp();
        ditchMutationsUntilRef.current = mutationStartedAt;
        setState({
          isMutating: true
        });
        try {
          const data = await mutate(
            serializedKey,
            fetcherRef.current(resolvedKey, {
              arg
            }),
            // We must throw the error here so we can catch and update the states.
            mergeObjects(options, {
              throwOnError: true
            })
          );
          if (ditchMutationsUntilRef.current <= mutationStartedAt) {
            setState({
              data,
              isMutating: false,
              error: void 0
            });
            options.onSuccess == null ? void 0 : options.onSuccess(data, serializedKey, options);
          }
          return data;
        } catch (error) {
          if (ditchMutationsUntilRef.current <= mutationStartedAt) {
            setState({
              error,
              isMutating: false
            });
            options.onError == null ? void 0 : options.onError(error, serializedKey, options);
            if (options.throwOnError) {
              throw error;
            }
          }
        }
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      []
    );
    const reset = (0, import_react.useCallback)(() => {
      ditchMutationsUntilRef.current = getTimestamp();
      setState({
        data: UNDEFINED,
        error: UNDEFINED,
        isMutating: false
      });
    }, []);
    useIsomorphicLayoutEffect(() => {
      keyRef.current = key;
      fetcherRef.current = fetcher;
    });
    return {
      trigger,
      reset,
      get data() {
        stateDependencies.data = true;
        return currentState.data;
      },
      get error() {
        stateDependencies.error = true;
        return currentState.error;
      },
      get isMutating() {
        stateDependencies.isMutating = true;
        return currentState.isMutating;
      }
    };
  };
};
var index = withMiddleware(useSWR, mutation);
export {
  index as default
};
//# sourceMappingURL=swr_mutation.js.map
